/**
 * functions.c -- программа "функции для решения Гипотезы Гольбаха и Индексирования простых чисел"
 *
 * Copyright (c) 2018, Zakharov Kirill <zaharov@cs.karelia.ru>
 *
 * This code is licensed under a MIT-style license.
 */
#include <stdio.h>
int calcsimp(int x)
{
    int j;
    int i;
    int primes[1001] = { 0 };   /*Изначально обнуляем элементы массива, чтобы потом обозначить еденицами эл. массива, индексы которых простые числа */
    int k = 0;                  /*к - количество делителей числа */
    primes[2] = 1;              /*Отдельный случай: 2 - простое число */
    for (i = 3; i < 1001; i++) {
        for (j = 1; j <= i; j++) {  /*Вложенные циклы для перебора деления числа i на все числа от 1 до i */
            if (i % j == 0)
                k += 1;         /*если остатка от деления нет, значит кол-во делителей становится на 1 больше */
        }
        if (k == 2)             /*У простых чисел всего 2 делителя */
            primes[i] = 1;      /*Элемент массива с индексом i становится равным 1 (следовательно i - прстое число) */
        k = 0;                  /*обнуляем количество делителей для следующего числа */
    }
    return (primes[x]);
}


void sigma(int n, int a[1000])
{
    int i;
    int j;
    int k = 0;
    int m = 1001;
    for (i = 1; i < n; i++) {   /*Вложенные циклы для проверки суммы любых двух элементов массива */
        for (j = 1; j < n; j++) {
            if ((a[i] + a[j] == n) && (i <= j)) {   /*1 условие - сумма равна искомому числу, 2 условие первое слагаемое либо совпадает со вторым, либо идёт раньше (это необходимо чтобы избежать повторов) */
                k += 1;         /*к - количество способов суммы двух чисел чтобы получилось искомое */
                if (a[i] < m)   /*Нахождение минимального слагаемого */
                    m = a[i];   /*Нахождение минимального слагаемого */
            }
        }
    }
    printf("  %d   %d   %d \n", k, m, n - m);   /*Вывод Количества способов, минимального слагаемого, второго слагаемого */
}
